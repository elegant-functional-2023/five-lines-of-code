# 3장 긴 코드 조각내기

## 3.1 첫 번째 규칙: 왜 다섯 줄인가?

### 3.1.1 규칙: 다섯 줄 제한

- 공백, 중괄호 제외하고 5줄이 넘으면 안된다.
- 메서드가 길면 한 번에 긴 메서드의 모든 논리를 머리에 담아야 해서 안 좋다.
- 메서드는 한 가지 작업만 해야 한다.

## 3.2 함수 분해를 위한 리팩터링 패턴 소개

### 3.2.1 리팩터링 패턴: 메서드 추출

- 한 메서드의 일부를 취해서 자체 메서드로 추출

## 3.3 추상화 수준을 맞추기 위한 함수 분해

### 3.3.1 규칙: 호출 또는 전달, 한 가지만 할 것

- 함수 내 객체에 있는 메서드를 호출하거나, 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안 된다.
- "직접 조작하는 낮은 수준의 작업"과 "다른 함수에 인자로 전달하는 높은 수준의 호출"이 공존하면 좋지 않다.
- 함수의 내용은 동일한 추상화 수준에 있어야 한다. 

### 3.3.2 규칙 적용

- g의 메서드를 호출하기 / g를 인자로 전달하기
- 매개변수로 전달되기도 하면서 메서드를 호출하는 서로 다른 동작은 구분해준다.

## 3.4 좋은 함수 이름의 속성

- createGraphics: HTML 요소를 가져오고, 캔버스를 인스턴스화하고, 캔버스를 지운다. == 그래픽 객체를 만든다.

## 3.5 너무 많은 일을 하는 함수 분리하기

### 3.5.1 규칙: if 문은 함수의 시작에만 배치

- if 문이 메서드가 하는 유일한 일(무언가를 확인하는 일)이어야 한다.
- else문과 분리해서는 안된다.

### 3.5.2 규칙 적용

- 메서드 추출의 또다른 장점: 새로운 메서드에서 더 많은 정보를 제공할 수 있는 새로운 이름을 매개변수에 지정해 가독성을 높인다. (`current` -> `input`)

# 4장 타입 코드 처리하기

## 4.1 간단한 if 문 리팩터링

### 4.1.1 규칙: if 문에서 else를 사용하지 말 것

- invalid 타입 필터링하는 게 아니라면 else를 사용하지 말 것
- if-else를 사용하면 코드에서 결정이 내려지는 지점을 고정하게 되며, 이 위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어진다.
- if-else는 하드코딩된 결정으로 볼 수 있다 -> 대신 외부의 데이터타입을 내부에서 제어 가능한 데이터 타입으로 매핑하자.
- 독립된 if문은 검사(check) vs. if-else문은 의사결정(decision)
- 이른 바인딩(early-binding) vs. 늦은 바인딩(late-binding)
  - 이른 바인딩은 컴파일 시 처리되어 애플리케이션에 고정, if문을 수정해야 변경할 수 있다.
  - 늦은 바인딩은 코드가 실행되는 순간에 동작이 결정, 추가를 통한 변경이 가능하다.

### 4.1.2 규칙 적용

- Input을 enum에서 interface로 바꿔서 if-else 제거하기
- 값들은 클래스로 바뀌고, 값이 이제 객체가 되었기 때문에 if 구문 내의 코드를 각 클래스의 메서드로 옮길 수 있다. 

### 4.1.3 리팩터링 패턴: 클래스로 타입 코드 대체

- 열거형을 인터페이스로 변환, 열거형의 값들을 클래스화, 각 값에 속성을 추가하고, 해당 특정 값과 관련된 기능을 특성에 맞게 설정
- 기능과 데이터를 함께 제공, 기능을 해당 값의 특징에 맞게 만들 수 있다. 
  - 인터페이스를 구현한 새로운 클래스를 추가하는 것은 해당 클래스에 메서드의 구현이 필요할 뿐, 새로운 클래스를 사용하기 전까지는 다른 코드를 수정하지 않아도 된다.
- c.f. switch 또는 else if 체인은 열거형이 가지는 값들이 처리되어야 하는 방식을 한곳에 기술한 것
  - 열거형에 새 값을 추가하는 것은 수많은 파일에 걸쳐서 해당 열거형과 연결된 로직들을 확인해야 한다.
- 열거형 값들은 밀접하게 연결되어 있는 반면, 메서드는 하나씩 처리할 수 있다? 

### 4.1.4 클래스로 코드 이관하기

- `handleInput`을 각 클래스에서 처리하고, 이를 `input.handle`로 호출

### 4.1.5 리팩터링 패턴: 클래스로의 코드 이관

- 기능을 클래스로 옮김으로써 if 구문이 제거되고, 기능이 데이터에 더 가까이 이동한다.
- 특정 값과 연결된 기능이 값에 해당하는 클래스로 이동하기 때문에 이는 불변속성을 지역화 하는데에 도움이 된다.
- 메서드 전체를 클래스로 옮긴다.
  - 원래 함수를 복사하여 모든 클래스로 붙여 넣고, function 키워드 제거
  - 컨텍스트를 this로 바꾼 후 사용하지 않는 매개변수 제거
  - 조건식을 제거

### 4.1.6 불필요한 메서드 인라인화

- handleInput은 더이상 필요하지 않으므로 제거


### 4.1.7

