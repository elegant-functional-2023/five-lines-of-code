# 3장 긴 코드 조각내기

## 3.1 첫 번째 규칙: 왜 다섯 줄인가?

### 3.1.1 규칙: 다섯 줄 제한

- 공백, 중괄호 제외하고 5줄이 넘으면 안된다.
- 메서드가 길면 한 번에 긴 메서드의 모든 논리를 머리에 담아야 해서 안 좋다.
- 메서드는 한 가지 작업만 해야 한다.

## 3.2 함수 분해를 위한 리팩터링 패턴 소개

### 3.2.1 리팩터링 패턴: 메서드 추출

- 한 메서드의 일부를 취해서 자체 메서드로 추출

## 3.3 추상화 수준을 맞추기 위한 함수 분해

### 3.3.1 규칙: 호출 또는 전달, 한 가지만 할 것

- 함수 내 객체에 있는 메서드를 호출하거나, 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안 된다.
- "직접 조작하는 낮은 수준의 작업"과 "다른 함수에 인자로 전달하는 높은 수준의 호출"이 공존하면 좋지 않다.
- 함수의 내용은 동일한 추상화 수준에 있어야 한다. 

### 3.3.2 규칙 적용

- g의 메서드를 호출하기 / g를 인자로 전달하기
- 매개변수로 전달되기도 하면서 메서드를 호출하는 서로 다른 동작은 구분해준다.

## 3.4 좋은 함수 이름의 속성

- createGraphics: HTML 요소를 가져오고, 캔버스를 인스턴스화하고, 캔버스를 지운다. == 그래픽 객체를 만든다.

## 3.5 너무 많은 일을 하는 함수 분리하기

### 3.5.1 규칙: if 문은 함수의 시작에만 배치

- if 문이 메서드가 하는 유일한 일(무언가를 확인하는 일)이어야 한다.
- else문과 분리해서는 안된다.

### 3.5.2 규칙 적용

- 메서드 추출의 또다른 장점: 새로운 메서드에서 더 많은 정보를 제공할 수 있는 새로운 이름을 매개변수에 지정해 가독성을 높인다. (`current` -> `input`)



# 4장 타입 코드 처리하기

## 4.1 간단한 if 문 리팩터링

### 4.1.1 규칙: if 문에서 else를 사용하지 말 것

- invalid 타입 필터링하는 게 아니라면 else를 사용하지 말 것
- if-else를 사용하면 코드에서 결정이 내려지는 지점을 고정하게 되며, 이 위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어진다.
- if-else는 하드코딩된 결정으로 볼 수 있다 -> 대신 외부의 데이터타입을 내부에서 제어 가능한 데이터 타입으로 매핑하자.
- 독립된 if문은 검사(check) vs. if-else문은 의사결정(decision)
- 이른 바인딩(early-binding) vs. 늦은 바인딩(late-binding)
  - 이른 바인딩은 컴파일 시 처리되어 애플리케이션에 고정, if문을 수정해야 변경할 수 있다.
  - 늦은 바인딩은 코드가 실행되는 순간에 동작이 결정, 추가를 통한 변경이 가능하다.

### 4.1.2 규칙 적용

- Input을 enum에서 interface로 바꿔서 if-else 제거하기
- 값들은 클래스로 바뀌고, 값이 이제 객체가 되었기 때문에 if 구문 내의 코드를 각 클래스의 메서드로 옮길 수 있다. 

### 4.1.3 리팩터링 패턴: 클래스로 타입 코드 대체

- 열거형을 인터페이스로 변환, 열거형의 값들을 클래스화, 각 값에 속성을 추가하고, 해당 특정 값과 관련된 기능을 특성에 맞게 설정
- 기능과 데이터를 함께 제공, 기능을 해당 값의 특징에 맞게 만들 수 있다. 
  - 인터페이스를 구현한 새로운 클래스를 추가하는 것은 해당 클래스에 메서드의 구현이 필요할 뿐, 새로운 클래스를 사용하기 전까지는 다른 코드를 수정하지 않아도 된다.
- c.f. switch 또는 else if 체인은 열거형이 가지는 값들이 처리되어야 하는 방식을 한곳에 기술한 것
  - 열거형에 새 값을 추가하는 것은 수많은 파일에 걸쳐서 해당 열거형과 연결된 로직들을 확인해야 한다.
- 열거형 값들은 밀접하게 연결되어 있는 반면, 메서드는 하나씩 처리할 수 있다? 

### 4.1.4 클래스로 코드 이관하기

- `handleInput`을 각 클래스에서 처리하고, 이를 `input.handle`로 호출

### 4.1.5 리팩터링 패턴: 클래스로의 코드 이관

- 기능을 클래스로 옮김으로써 if 구문이 제거되고, 기능이 데이터에 더 가까이 이동한다.
- 특정 값과 연결된 기능이 값에 해당하는 클래스로 이동하기 때문에 이는 불변속성을 지역화 하는데에 도움이 된다.
- 메서드 전체를 클래스로 옮긴다.
  - 원래 함수를 복사하여 모든 클래스로 붙여 넣고, function 키워드 제거
  - 컨텍스트를 this로 바꾼 후 사용하지 않는 매개변수 제거
  - 조건식을 제거

### 4.1.6 불필요한 메서드 인라인화

- handleInput은 더이상 필요하지 않으므로 제거


### 4.1.7 리팩터링 패턴: 메서드의 인라인화

- 한 줄 또는 더 이상 가독성에 도움이 되지 않는 메서드의 경우 메서드를 제거하고, 모든 호출 측에 메서드의 코드를 넣는다.
- 인라인화 하기에 너무 복잡하지 않은지 (낮은 수준의 연산에 의존하며 메서드로 존재하는 것이 가독성에 도움이 되고 있는지)
- 따로 쓰일 때 잘못 쓰일 여지가 있는 함수(deposit)를 인라인화 한다. (이것이 바람직한지는 6장에서 확인하자)

## 4.2 긴 if 문의 리팩터링

- else if 체인 구문을 독자적인 메서드로 추출

### 4.2.1 일반성 제거

- lock1, lock2 에 대해서만 remove 메서드를 실행하므로, 일반화를 줄이고 removeLock1, removeLock2 라는 보다 특정화한 버전의 함수를 도입
- 이를 메서드 전문화라고 부른다.

### 4.2.2 리팩터링 패턴: 메서드 전문화

- 일반화하고 재사용하려는 본능적인 욕구 -> 책임이 흐려지고 다양한 위치에서 코드를 호출할 수 있다는 문제가 있다
- 전문화된 메서드는 더 적은 위치에서 호출되어, 필요성이 없어지면 더 빨리 제거할 수 있다.


### 4.2.3 switch가 허용되는 유일한 경우

- 더 이상 동작하지 않는 열거형 인덱스를 사용해서 map을 생성하고 있다는 문제가 남았다.
- transformTile 이라는 새로운 메서드를 만들어 RawTile 열거형을 Tile2 객체로 변환
- transformMap 이라는 새로운 메서드로 맵 전체를 transformTile로 매핑
- 그러나 transformTile은 switch문을 사용하며, 다섯 줄 제한을 위반하고 타입스크립트의 트릭을 사용해 예외 케이스로 겨우 피해감

### 4.2.4 규칙: switch를 사용하지 말 것

- default 케이스가 없고 모든 case에 반환 값이 있는 경우가 아니라면 switch를 사용하지 말 것
- switch의 문제
  - 모든 값에 대한 처리를 실행할 필요가 없다. default 키워드를 사용하면 새로 추가한 값이 default에 지정한 것인지, 아니면 추가 처리를 잊은 것인지 알 길이 없다.
  - break 키워드를 사용하는 것을 잊으면 fall-through (break 키워드를 만나기 전까지 케이스를 연속해서 실행) 발생
- 문제 해결
  - 기능을 default에 두지 않는다.
  - 모든 케이스에 return을 지정
- assertExhausted 트릭을 사용하여 컴파일러가 모든 값을 매핑했는지 확인할 수 있게 한다.
- switch는 컨텍스트(값 x를 처리하는 방법에 초점, 데이터에서 불변속성을 더 멀리 위치시켜 불변속성을 전역화하는 것
  - c.f. 클래스에 기능을 밀어넣을 때는 데이터, 즉 이 값(객체)이 상황 x를 처리하는 방법에 초점을 맞춘다.

### 4.2.5 if 제거하기

- colorOfTile을 각 클래스 안에 각자의 데이터에 대한 색깔 설정하는 메서드로 내재화


## 4.3 코드 중복 처리

### 4.3.1 인터페이스 대신 추상 클래스를 사용할 수는 없을까? 

- 인터페이스를 사용하면, 이를 통해 도입한 각각의 새로운 클래스에 대해 개발자가 잊지 말아야 하는 속성의 오버라이드를 방지할 수 있다.
- 새로운 Tile 유형을 추가해야 하는 경우 등
- 추상 클래스를 사용하지 못하도록 "인터페이스에서만 상속받을 것"이라는 규칙으로 공식화.

### 4.3.2 규칙: 인터페이스에서만 상속받을 것

- 추상 클래스를 사용하는 이유: 일부 메서드에서는 기본 구현을 제공하고 다른 메서드는 추상화하기 위한 것
- 그러나 코드 공유는 커플링(결합)을 유발, 추상 클래스의 코드를 원하든 원하지 않든 공유한다 (빈 메서드로 재정의하지 않는 이상)
- 기본 구현된 메서드가 있는 경우 
  - 가능한 모든 하위 클래스에 해당 메서드가 필요한 경우: 메서드를 클래스 밖으로 쉽게 이동할 수 있다.
  - 일부 하위 클래스에서 메서드를 재정의해야 하는 경우: 기본 구현이 있기 때문에 컴파일러를 통해 재정의가 필요한 메서드인지 잡아낼 수 없다.
- 명시적으로 처리할 필요가 있기 때문에 완전히 추상화된 메서드로 남겨두는 것이 좋다. 
- 여러 클래스에서 코드를 공유해야 하는 경우, 해당 코드를 다른 공유 클래스에 넣는다: 상속보다는 컴포지션이 더 좋다는 원칙

### 4.3.3 클래스에 있는 코드의 중복은 다 무엇일까? 

- 복제된 코드가 있고 한곳에서 변경하면 두 가지 다른 기능이 존재 == 코드중복은 분기를 조장하기 때문에 나쁘다.

## 4.4 복잡한 if 체인 구문 리팩터링

- moveHorizontal, moveVertical 메서드를 Tile에 넣고, Box와 Stone에만 해당 복잡성을 포함시킨다.

## 4.5 필요 없는 코드 제거하기

### 4.5.1 리팩터링 패턴: 삭제 후 컴파일하기

- 인터페이스에서 사용하지 않는 메서드를 제거하기
- 아직 사용하지 않는 메서드를 삭제할 수 있으니 새로운 기능을 구현할 때는 주의해야 함
- 인터페이스 안에 있는 메서드는 수동으로 정리해야만 하기 때문에 삭제한 후 컴파일되는지를 통해 사용 여부를 확인해야 함