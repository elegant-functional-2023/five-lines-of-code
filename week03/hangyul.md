# 5장 유사한 코드 융합하기

## 5.1 유사한 클래스 통합하기

- Stone, FallingStone과 Box, FallingBox의 같은 성질(isStony isBoxy)을 가진 것으로 간주
- isStone, isBox 는 이제 없앨 수 있다. (isStony, isBoxy로 대체)
- Box, FallingBox / Stone, FallingStone은 경우에 따라 다른 값을 반환하는 상수 메서드를 공유 (moveHorizontal)
  - 두 클래스를 합칠 수 있다.
  - 상수 메서드(constant method): 메서드가 상수를 반환하는 것
- 두 개의 클래스를 합치는 방법
  - (분수에서 분모를 동일하게 만들 듯) 상수 메서드를 제외한 클래스의 모든 것을 동일하게 만든다.
  - (분수에서 실제 더하기를 하듯) 실제로 합친다.
- Stone과 FallingStone 합치기
  - moveHorizontal 에서 isFallingStone일 때 달리 동작하는 부분을 `if (isFallingStone이 false) else if (isFallingStone이 true)`문으로 변경
  - isFallingStone 메서드 대신 필드(falling)를 만들고 constructor에서 매개변수를 통해 받은 값을 할당하여 이를 반환
  - Stone을 생성하며 falling 값을 true로 넣으면 falling stone, 아니면 그냥 stone
- 이렇게 합치고 나면 moveHorizontal이 if else 구문을 가지고 있다는 안티패턴을 볼 수 있다. 
  - 일반적인 기대효과는 잠재적으로 숨겨진 타입을 가리키는 코드를 찾을 수 있다는 점
  - falling은 타입을 가리키는 코드이므로 이 코드를 열거형으로 만들어 노출시킬 수 있다. 
  - 열거형에 대하여, 클래스로 타입 코드 대체 리팩터링을 할 수도 있다. 
    - FallingState interface와 이를 상속하는 Falling, Resting 클래스를 만들고, Stone을 생성할 때에 이 클래스들을 생성하여 falling이라는 매개변수의 인자로 전달한다.
    - `return this.falling === FallingState.FALLING` -> `return this.falling.isFalling()`
  - isFallingStone으로 if/else 분기처리하던 것을 없애고 FallingState 인터페이스 및 상속 클래스에 메서드로 moveHorizontal를 만든다.

### 5.1.1 리팩터링 패턴: 유사 클래스 통합

- 일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서, 이 상수 메서드가 클래스에 따라 다른 값을 반환할 때 클래스를 통합할 수 있다.
- 이 일련의 상수 메서드 집합은 기준(basis)이라 하며, 두 개일 때 **두 개의 접점을 가진 기준**이라고 한다.
- 가능한 한 적은 메서드를 가진 기준을 원한다. 클래스의 수가 적어진다는 것은 더 많은 구조를 발견했다는 것을 의미한다.
  - 모든 비기준 메서드를 동일하게 만들기
  - 기준 메서드만 다르게 하고, 각 메서드에 대한 필드를 도입하고 생성자에서 상수를 할당
  - 상수 대신 도입한 필드를 반환하도록 메서드를 변경
  - 필드의 기본값을 매개변수로 지정하게 하며, 생성할 때 기본값을 인자로 전달
  - 모든 클래스가 동일하면 하나만 남기고 모두 삭제

## 5.2 단순한 조건 통합하기

### 5.2.1 리팩터링 패턴: if 문 결합

- 내용이 동일한 연속적인 If문을 결합하여 중복을 제거
- `||`를 추가해서 두 식의 관계를 드러낸다.

## 5.3 복잡한 조건 통합하기

### 5.3.1 조건을 위한 산술 규칙 사용

- `||` 은 `+` 처럼 동작, `&&`은 `x` 처럼 동작
- 덧셈과 곱셈의 결합법칙, 교환법칙을 따른다.

### 5.3.2 규칙: 순수 조건 사용

- 조건: if 또는 while 뒤에 오는 것과, for 루프의 가운데에 있는 것
- 조건은 항상 순수 조건이어야 한다 === 조건에 부수적인 동작이 없음
  - 부수적인 동작이 존재하면 앞서 말한 결합법칙, 교환법칙 등을 사용할 수 없다.
  - 부수적인 동작이 조건 안에 있을것으로 예상하지 못하므로, 추적하기에 어렵다.
- 캐시를 사용하여 부수적인 동작을 반환 부분과 분리할 수 있다?
- 명령에서 질의 분리(Separate queries from commands)
  - 명령: 부수효과가 있는 모든 것
  - 질의: 순수한 것
  - void 메서드에서만 부수적인 동작을 허용한다. 그러면 부수적인 동작을 하거나 반환하는 것 중 하나만 하게된다.
- 이 책에서는 위의 규칙을 순화해서, 조건 안에서만 질의와 명령을 분리

### 5.3.3 조건 산술 적용

- 조건을 산술계산과 같이 재배열한 후 비슷한 성질을 새로운 메서드(`canFall`)로 빼내어 처리해준다.

## 5.4 클래스 간의 코드 통합

- stone과 box는 떨어지는 동작이라는 같은 동작을 하므로 코드를 통합할 수 있다.
- 떨어지는 동작을 통합하기 위한 **전략 패턴의 도입**
- 이 효과를 설명하기 위해서 UML 클래스 다이어그램을 사용한다.

### 5.4.1 클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개

- Unified Modeling Language
- 아키텍쳐나 일이 일어나는 순서 같은, 코드에 대한 속성을 다이어그램으로 쉽게 전달
- 클래스 다이어그램은 인터페이스와 클래스의 구조가 서로 어떤 관계가 있는지 보여준다.
- 클래스의 공용인터페이스가 주된 관심이므로 공개 메서드만을 묘사
- 클래스와 인터페이스 간의 관계
  - X가 Y를 사용한다
  - X는 Y다
  - X가 하나 또는 여러 개의 Y를 가진다
- 컴포지션과 집합(aggregation)의 차이는 표현의 차이이며, 대부분 컴포지션과 구현(implemetation)이라는 관계 유형을 사용

### 5.4.2 리팩터링 패턴: 전략 패턴의 도입

- 4장에서 이미 if 문이 저수준 제어 흐름 연산자로 쓰이는 방법과, 객체를 사용하는 것이 어떻게 유리한지에 대해 언급했다. ( 언제? ㅠㅠ )
- 전략패턴: 다른 클래스를 인스턴스화해서 변형(variance)을 도입하는 개념
  - c.f. 상태패턴: 전략이 상태를 가지고 있는 경우
  - 클래스를 추가해서 변경이 가능하게 하는 것
  - 새로운 변형을 추가하지 않더라도 확장성을 가질 수 있다.
- 타입을 가리키는 코드를 클래스로 변환하는 것과 다르다.
  - 이는 데이터를 나타내므로 많은 메서드를 해당 클래스에 밀어 넣는 경향이 있다.
- 전략클래스가 완료된 후 메서드를 추가하는 경우는 거의 없으며 대신 기능을 변경해야 하는 경우 새로운 클래스를 만드는 것을 선호한다.
- 변형(전략)은 전략 패턴의 목적이므로 항상 상속으로 묘사된다. 
  - 늦은 바인딩의 궁극적인 형태
  - 런타임에 전략 패턴을 사용하면 코드에 사용자 정의 클래스를 적재하고 이를 제어 흐름에 원활하게 통합할 수 있다.
- 전략 패턴 도입 상황
  - 코드에 변형을 도입하고 싶어서 리팩터링을 수행하는 경우 (결국 인터페이스가 있어야 하지만 나중에 만드는 것이 좋다.)
  - 떨어지는 성질을 코드화했던 상황에서, 바로 변형의 추가가 필요하다고 예상하지 않았을 때 ( === 클래스 간의 동작을 통합하려는 경우 )


### 5.4.3 규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것

- 단일 구현체를 가진 인터페이스가 있으면 안 된다. 구현 클래스가 하나만 있는 인터페이스는 도움이 안 되는 일반화일 뿐
  - 가독성에 도움이 되지 않는다.
  - 인터페이스는 변형을 전제로 하는데, 아무 것도 없다면 오히려 가독성을 방해할 수 있다.
  - 구현 클래스를 수정하려는 경우 인터페이스를 수정해야 해서, 오버헤드를 발생시킨다. : 메서드 전문화와 유사
- 인터페이스를 독립된 파일에 작성하는 경우, 구현 클래스가 하나 밖에 없는 인터페이스를 만들면 두 개의 파일을 사용. 구현 클래스만 있는 경우는 하나의 파일만 사용
  - 계속 이렇게 두 배의 파일을 쓰면 결국 오버헤드를 초래
- 아무런 구현체가 없는 인터페이스를 갖는 것이 합리적인 경우도 있다.
  - comparator(비교자)와 같은 항목에 대해 익명 클래스를 사용하거나, 익명의 내부 클래스를 통해 더 엄격한 캡슐화를 수행하려는 경우? 
- 인터페이스 : 컴퓨터 과학의 모든 문제는 간접 레이어를 도입함으로써 해결할 수 있다.
  - 세부적인 내용은 추상화 아래 숨긴다.
  - 추상화는 인지된 복잡성의 감소르르 위해 실제의 복잡성의 증가를 허용하는 것
- 의도: 불필요한 boilerplate 제한. 인터페이스는 상용구의 일반적인 원인

### 5.4.4 리팩터링 패턴: 구현에서 인터페이스 추출

- 인터페이스를 만드는 것을 필요할 때까지 연기 (변형을 도입하고싶을 때까지)

## 5.5 유사 함수 통합하기

- removeLock1, 2 함수의 통합
- RemoveStrategy를 인터페이스로 만들고, RemoveLock1, RemoveLock2가 이를 상속하여 removeLock1, 2함수에서 직접 인스턴스화한다.
- 하나의 remove 함수로 통합

## 5.6 유사한 코드 통합하기

- Key1, 2, Lock1, 2에서 중복되는 부분이 있으므로, 유사 클래스 통합 실시
- 색과 자물쇠 번호가 연결되어있으므로 Key와 Lock을 통해 한 쌍의 key+lock 쌍을 만들었다.


# 6 데이터 보호

- 우리는 이미 클래스를 통해 불변속성으르 가깝게 모아 지역화 -> 동일한 데이터에 대한 기능을 결합했다.
- 이번에는 데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지역에만 영향을 주게 만들자.

## 6.1 getter 없이 캡슐화하기

### 6.1.1 규칙: getter와 setter를 사용하지 말 것

- bool이 아닌 필드에 getter와 setter를 사용하지 말라
- setter / getter : bool이 아닌 필드를 직접 할당하거나 반환하는 메서드
  - private 필드를 다루기 위한 메서드
- 객체의 필드에 대한 getter가 존재하는 순간 캡슐화를 해제하고 불변속성을 전역화
  - 객체를 얻은 어느 곳에서나 public메서드를 호출할 수 있으며, 예상하지 못한 방식으로 객체를 수정 가능
- setter도 마찬가지, setter를 통한 새로운 데이터 구조를 반환하도록 getter를 수정하고 새로운 데이터구조를 받을 수 있도록 해야한다 
  - 이는 우리가 피해야 할 tight coupling
  - 내부 데이터 구조를 변경하고, 해당 setter를 수정해도 시그니처를 유지할 수 있는 다른 간접적인 레이어를 도입하는 것은 우리가 말하는 setter가 아니므로 괜춘
- 가변 객체에서만 발생하는 문제. 
- push based(푸시 기반)의 아키텍처를 장려: 필드를 비공개로 하는 것의 가장 큰 장점
  - 데이터에 가깝게 연산을 이관
  - c.f. pull based (풀 기반) 아키텍처: 데이터를 가져와 중앙에서 연산 수행
    - 풀 기반의 아키텍처에서는 기능을 수행하는 메서드 없이, 수동적 데이터 클래스와 관리자 클래스 (여기저기서 데이터를 혼합하여 모든 작업을 수행하는 소수) 존재
    - 데이터와 관리자 사이, 그리고 데이터 클래스 간에 tight coupling 초래
  - 푸시 기반 아키텍처에서는 데이터를 가져오는 대신 인자로 데이터를 전달. 
  - 모든 클래스가 자신의 기능을 가지고 있으며, 코등는 그 효용에 따라 분산
- 낯선 사람에게 말하지 말라(디미터/데메테르 법칙: Law of Demeter)
  - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다
  - 낯선 사람: 우리가 직접 접근할 수는 없지만 참조를 얻을 수 있는 객체
  - 객체 지향 언어에서는 이런 일이 일반적으로 getter를 통해 존재
- 참조를 얻을 수 있는 객체와 상호작용할 때의 문제: 객체를 가져오는 방식과 tight coupling
  - 객체 소유자의 내부 구조에 대해 어느 정도 알고 있어야 한다.
  - 필드 소유자가 이전 데이터 구조를 획득하는 방법을 계속 지원하지 않는 한 데이터 구조를 변경할 수 없다.
  - c.f. 푸시 기반 아키텍쳐에서는 서비스와 같은 메서드를 노출. 사용하는 메서드 내부 구조에 대해 신경쓰지 않아도 된다.

### 6.1.2 규칙 적용하기

- pull based -> push based

### 6.1.3 리팩터링 패턴: getter와 setter 제거하기

- 기능을 데이터에 더 가깝게 이동하여 getter와 setter를 제거해보자
- 코드를 데이터에 더 가깝게 이동함으로써 불변 속성을 지역화
- getter를 비공개로 바꾸고, 클래스로의 코드 이관을 실행한 후 getter를 인라인화 

### 6.1.4 마지막 getter 삭제

## 6.2 간단한 데이터 캡슐화하기

### 6.2.1 규칙: 공통 접사를 사용하지 말 것

- 코드에는 공통 접두사나 접미사가 있는 메서드나 변수가 없어야 한다.
- 여러 요소가 동일한 접사를 가진다 -> 요소들의 긴밀성
- 클래스로 이런 메서드와 변수를 그룹화
  - 외부 인터페이스를 완전하게 제어할 수 있다.
  - 도우미 메서드를 숨겨 전역 범위를 오염시키지 않을 수 있다.
    - 다섯 줄 제한 규칙은 많은 메서드를 도입하므로 특히 이 방법이 중요
  - 데이터를 숨김으로써 해당 불변속성이 클래스 내에서 관리
    - 지역 불변속성이 되어 유지보수하기가 더 쉬워진다.
- 단일 책임 원칙: '메서드는 한 가지 작업만 해야 한다'의 클래스 버전 -> 클래스에는 단 하나의 책임만 있어야 한다.

