# 5장 유사한 코드 융합하기

## 5.1 유사한 클래스 통합하기

- Stone, FallingStone과 Box, FallingBox의 같은 성질(isStony isBoxy)을 가진 것으로 간주
- isStone, isBox 는 이제 없앨 수 있다. (isStony, isBoxy로 대체)
- Box, FallingBox / Stone, FallingStone은 경우에 따라 다른 값을 반환하는 상수 메서드를 공유 (moveHorizontal)
  - 두 클래스를 합칠 수 있다.
  - 상수 메서드(constant method): 메서드가 상수를 반환하는 것
- 두 개의 클래스를 합치는 방법
  - (분수에서 분모를 동일하게 만들 듯) 상수 메서드를 제외한 클래스의 모든 것을 동일하게 만든다.
  - (분수에서 실제 더하기를 하듯) 실제로 합친다.
- Stone과 FallingStone 합치기
  - moveHorizontal 에서 isFallingStone일 때 달리 동작하는 부분을 `if (isFallingStone이 false) else if (isFallingStone이 true)`문으로 변경
  - isFallingStone 메서드 대신 필드(falling)를 만들고 constructor에서 매개변수를 통해 받은 값을 할당하여 이를 반환
  - Stone을 생성하며 falling 값을 true로 넣으면 falling stone, 아니면 그냥 stone
- 이렇게 합치고 나면 moveHorizontal이 if else 구문을 가지고 있다는 안티패턴을 볼 수 있다. 
  - 일반적인 기대효과는 잠재적으로 숨겨진 타입을 가리키는 코드를 찾을 수 있다는 점
  - falling은 타입을 가리키는 코드이므로 이 코드를 열거형으로 만들어 노출시킬 수 있다. 
  - 열거형에 대하여, 클래스로 타입 코드 대체 리팩터링을 할 수도 있다. 
    - FallingState interface와 이를 상속하는 Falling, Resting 클래스를 만들고, Stone을 생성할 때에 이 클래스들을 생성하여 falling이라는 매개변수의 인자로 전달한다.
    - `return this.falling === FallingState.FALLING` -> `return this.falling.isFalling()`
  - isFallingStone으로 if/else 분기처리하던 것을 없애고 FallingState 인터페이스 및 상속 클래스에 메서드로 moveHorizontal를 만든다.

### 5.1.1 리팩터링 패턴: 유사 클래스 통합

- 일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서, 이 상수 메서드가 클래스에 따라 다른 값을 반환할 때 클래스를 통합할 수 있다.
- 이 일련의 상수 메서드 집합은 기준(basis)이라 하며, 두 개일 때 **두 개의 접점을 가진 기준**이라고 한다.
- 가능한 한 적은 메서드를 가진 기준을 원한다. 클래스의 수가 적어진다는 것은 더 많은 구조를 발견했다는 것을 의미한다.
  - 모든 비기준 메서드를 동일하게 만들기
  - 기준 메서드만 다르게 하고, 각 메서드에 대한 필드를 도입하고 생성자에서 상수를 할당
  - 상수 대신 도입한 필드를 반환하도록 메서드를 변경
  - 필드의 기본값을 매개변수로 지정하게 하며, 생성할 때 기본값을 인자로 전달
  - 모든 클래스가 동일하면 하나만 남기고 모두 삭제

## 5.2 단순한 조건 통합하기

### 5.2.1 리팩터링 패턴: if 문 결합

- 내용이 동일한 연속적인 If문을 결합하여 중복을 제거
- `||`를 추가해서 두 식의 관계를 드러낸다.

## 5.3 복잡한 조건 통합하기

### 5.3.1 조건을 위한 산술 규칙 사용

- `||` 은 `+` 처럼 동작, `&&`은 `x` 처럼 동작
- 덧셈과 곱셈의 결합법칙, 교환법칙을 따른다.

### 5.3.2 규칙: 순수 조건 사용

- 조건: if 또는 while 뒤에 오는 것과, for 루프의 가운데에 있는 것
- 조건은 항상 순수 조건이어야 한다 === 조건에 부수적인 동작이 없음
  - 부수적인 동작이 존재하면 앞서 말한 결합법칙, 교환법칙 등을 사용할 수 없다.
  - 부수적인 동작이 조건 안에 있을것으로 예상하지 못하므로, 추적하기에 어렵다.
- 캐시를 사용하여 부수적인 동작을 반환 부분과 분리할 수 있다?
- 명령에서 질의 분리(Separate queries from commands)
  - 명령: 부수효과가 있는 모든 것
  - 질의: 순수한 것
  - void 메서드에서만 부수적인 동작을 허용한다. 그러면 부수적인 동작을 하거나 반환하는 것 중 하나만 하게된다.
- 이 책에서는 위의 규칙을 순화해서, 조건 안에서만 질의와 명령을 분리

### 5.3.3 조건 산술 적용

- 조건을 산술계산과 같이 재배열한 후 비슷한 성질을 새로운 메서드(`canFall`)로 빼내어 처리해준다.


  