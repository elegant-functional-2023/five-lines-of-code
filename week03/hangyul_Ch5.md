# 5장 유사한 코드 융합하기

## 5.1 유사한 클래스 통합하기

- Stone, FallingStone과 Box, FallingBox의 같은 성질(isStony isBoxy)을 가진 것으로 간주
- isStone, isBox 는 이제 없앨 수 있다. (isStony, isBoxy로 대체)
- Box, FallingBox / Stone, FallingStone은 경우에 따라 다른 값을 반환하는 상수 메서드를 공유 (moveHorizontal)
  - 두 클래스를 합칠 수 있다.
  - 상수 메서드(constant method): 메서드가 상수를 반환하는 것
- 두 개의 클래스를 합치는 방법
  - (분수에서 분모를 동일하게 만들 듯) 상수 메서드를 제외한 클래스의 모든 것을 동일하게 만든다.
  - (분수에서 실제 더하기를 하듯) 실제로 합친다.
- Stone과 FallingStone 합치기
  - moveHorizontal 에서 isFallingStone일 때 달리 동작하는 부분을 `if (isFallingStone이 false) else if (isFallingStone이 true)`문으로 변경
  - isFallingStone 메서드 대신 필드(falling)를 만들고 constructor에서 매개변수를 통해 받은 값을 할당하여 이를 반환
  - Stone을 생성하며 falling 값을 true로 넣으면 falling stone, 아니면 그냥 stone
- 이렇게 합치고 나면 moveHorizontal이 if else 구문을 가지고 있다는 안티패턴을 볼 수 있다. 
  - 일반적인 기대효과는 잠재적으로 숨겨진 타입을 가리키는 코드를 찾을 수 있다는 점
  - falling은 타입을 가리키는 코드이므로 이 코드를 열거형으로 만들어 노출시킬 수 있다. 
  - 열거형에 대하여, 클래스로 타입 코드 대체 리팩터링을 할 수도 있다. 
    - FallingState interface와 이를 상속하는 Falling, Resting 클래스를 만들고, Stone을 생성할 때에 이 클래스들을 생성하여 falling이라는 매개변수의 인자로 전달한다.
    - `return this.falling === FallingState.FALLING` -> `return this.falling.isFalling()`
  - isFallingStone으로 if/else 분기처리하던 것을 없애고 FallingState 인터페이스 및 상속 클래스에 메서드로 moveHorizontal를 만든다.

### 5.1.1 리팩터링 패턴: 유사 클래스 통합

- 일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서, 이 상수 메서드가 클래스에 따라 다른 값을 반환할 때 클래스를 통합할 수 있다.
- 이 일련의 상수 메서드 집합은 기준(basis)이라 하며, 두 개일 때 **두 개의 접점을 가진 기준**이라고 한다.
- 가능한 한 적은 메서드를 가진 기준을 원한다. 클래스의 수가 적어진다는 것은 더 많은 구조를 발견했다는 것을 의미한다.
  - 모든 비기준 메서드를 동일하게 만들기
  - 기준 메서드만 다르게 하고, 각 메서드에 대한 필드를 도입하고 생성자에서 상수를 할당
  - 상수 대신 도입한 필드를 반환하도록 메서드를 변경
  - 필드의 기본값을 매개변수로 지정하게 하며, 생성할 때 기본값을 인자로 전달
  - 모든 클래스가 동일하면 하나만 남기고 모두 삭제

## 5.2 단순한 조건 통합하기

### 5.2.1 리팩터링 패턴: if 문 결합

- 내용이 동일한 연속적인 If문을 결합하여 중복을 제거
- `||`를 추가해서 두 식의 관계를 드러낸다.

## 5.3 복잡한 조건 통합하기

### 5.3.1 조건을 위한 산술 규칙 사용

- `||` 은 `+` 처럼 동작, `&&`은 `x` 처럼 동작
- 덧셈과 곱셈의 결합법칙, 교환법칙을 따른다.

### 5.3.2 규칙: 순수 조건 사용

- 조건: if 또는 while 뒤에 오는 것과, for 루프의 가운데에 있는 것
- 조건은 항상 순수 조건이어야 한다 === 조건에 부수적인 동작이 없음
  - 부수적인 동작이 존재하면 앞서 말한 결합법칙, 교환법칙 등을 사용할 수 없다.
  - 부수적인 동작이 조건 안에 있을것으로 예상하지 못하므로, 추적하기에 어렵다.
- 캐시를 사용하여 부수적인 동작을 반환 부분과 분리할 수 있다?
- 명령에서 질의 분리(Separate queries from commands)
  - 명령: 부수효과가 있는 모든 것
  - 질의: 순수한 것
  - void 메서드에서만 부수적인 동작을 허용한다. 그러면 부수적인 동작을 하거나 반환하는 것 중 하나만 하게된다.
- 이 책에서는 위의 규칙을 순화해서, 조건 안에서만 질의와 명령을 분리

### 5.3.3 조건 산술 적용

- 조건을 산술계산과 같이 재배열한 후 비슷한 성질을 새로운 메서드(`canFall`)로 빼내어 처리해준다.

## 5.4 클래스 간의 코드 통합

- stone과 box는 떨어지는 동작이라는 같은 동작을 하므로 코드를 통합할 수 있다.
- 떨어지는 동작을 통합하기 위한 **전략 패턴의 도입**
- 이 효과를 설명하기 위해서 UML 클래스 다이어그램을 사용한다.

### 5.4.1 클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개

- Unified Modeling Language
- 아키텍쳐나 일이 일어나는 순서 같은, 코드에 대한 속성을 다이어그램으로 쉽게 전달
- 클래스 다이어그램은 인터페이스와 클래스의 구조가 서로 어떤 관계가 있는지 보여준다.
- 클래스의 공용인터페이스가 주된 관심이므로 공개 메서드만을 묘사
- 클래스와 인터페이스 간의 관계
  - X가 Y를 사용한다
  - X는 Y다
  - X가 하나 또는 여러 개의 Y를 가진다
- 컴포지션과 집합(aggregation)의 차이는 표현의 차이이며, 대부분 컴포지션과 구현(implemetation)이라는 관계 유형을 사용

### 5.4.2 리팩터링 패턴: 전략 패턴의 도입

- 4장에서 이미 if 문이 저수준 제어 흐름 연산자로 쓰이는 방법과, 객체를 사용하는 것이 어떻게 유리한지에 대해 언급했다. ( 언제? ㅠㅠ )
- 전략패턴: 다른 클래스를 인스턴스화해서 변형(variance)을 도입하는 개념
  - c.f. 상태패턴: 전략이 상태를 가지고 있는 경우
  - 클래스를 추가해서 변경이 가능하게 하는 것
  - 새로운 변형을 추가하지 않더라도 확장성을 가질 수 있다.
- 타입을 가리키는 코드를 클래스로 변환하는 것과 다르다.
  - 이는 데이터를 나타내므로 많은 메서드를 해당 클래스에 밀어 넣는 경향이 있다.
- 전략클래스가 완료된 후 메서드를 추가하는 경우는 거의 없으며 대신 기능을 변경해야 하는 경우 새로운 클래스를 만드는 것을 선호한다.
- 변형(전략)은 전략 패턴의 목적이므로 항상 상속으로 묘사된다. 
  - 늦은 바인딩의 궁극적인 형태
  - 런타임에 전략 패턴을 사용하면 코드에 사용자 정의 클래스를 적재하고 이를 제어 흐름에 원활하게 통합할 수 있다.
- 전략 패턴 도입 상황
  - 코드에 변형을 도입하고 싶어서 리팩터링을 수행하는 경우 (결국 인터페이스가 있어야 하지만 나중에 만드는 것이 좋다.)
  - 떨어지는 성질을 코드화했던 상황에서, 바로 변형의 추가가 필요하다고 예상하지 않았을 때 ( === 클래스 간의 동작을 통합하려는 경우 )


### 5.4.3 규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것

- 단일 구현체를 가진 인터페이스가 있으면 안 된다. 구현 클래스가 하나만 있는 인터페이스는 도움이 안 되는 일반화일 뿐
  - 가독성에 도움이 되지 않는다.
  - 인터페이스는 변형을 전제로 하는데, 아무 것도 없다면 오히려 가독성을 방해할 수 있다.
  - 구현 클래스를 수정하려는 경우 인터페이스를 수정해야 해서, 오버헤드를 발생시킨다. : 메서드 전문화와 유사
- 인터페이스를 독립된 파일에 작성하는 경우, 구현 클래스가 하나 밖에 없는 인터페이스를 만들면 두 개의 파일을 사용. 구현 클래스만 있는 경우는 하나의 파일만 사용
  - 계속 이렇게 두 배의 파일을 쓰면 결국 오버헤드를 초래
- 아무런 구현체가 없는 인터페이스를 갖는 것이 합리적인 경우도 있다.
  - comparator(비교자)와 같은 항목에 대해 익명 클래스를 사용하거나, 익명의 내부 클래스를 통해 더 엄격한 캡슐화를 수행하려는 경우? 
- 인터페이스 : 컴퓨터 과학의 모든 문제는 간접 레이어를 도입함으로써 해결할 수 있다.
  - 세부적인 내용은 추상화 아래 숨긴다.
  - 추상화는 인지된 복잡성의 감소를 위해 실제의 복잡성의 증가를 허용하는 것
- 의도: 불필요한 boilerplate 제한. 인터페이스는 상용구의 일반적인 원인

### 5.4.4 리팩터링 패턴: 구현에서 인터페이스 추출

- 인터페이스를 만드는 것을 필요할 때까지 연기 (변형을 도입하고싶을 때까지)

## 5.5 유사 함수 통합하기

- removeLock1, 2 함수의 통합
- RemoveStrategy를 인터페이스로 만들고, RemoveLock1, RemoveLock2가 이를 상속하여 removeLock1, 2함수에서 직접 인스턴스화한다.
- 하나의 remove 함수로 통합
- 다른 종류의 타일을 제거하고 싶을 때에도 RemoveStrategy를 상속받는 클래스를 만들어 쉽게 제거할 수 있다. 

## 5.6 유사한 코드 통합하기

- Key1, 2, Lock1, 2에서 중복되는 부분이 있으므로, 유사 클래스 통합 실시
- 색과 자물쇠 번호가 연결되어있으므로 Key와 Lock을 통해 한 쌍의 key+lock 쌍을 만들었다.


