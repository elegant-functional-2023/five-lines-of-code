# 6 데이터 보호

- 우리는 이미 클래스를 통해 불변속성으르 가깝게 모아 지역화 -> 동일한 데이터에 대한 기능을 결합했다.
- 이번에는 데이터와 기능에 대한 접근을 제한하는 캡슐화에 초점을 맞춰 불변속성이 지역에만 영향을 주게 만들자.

## 6.1 getter 없이 캡슐화하기

### 6.1.1 규칙: getter와 setter를 사용하지 말 것

- bool이 아닌 필드에 getter와 setter를 사용하지 말라
- setter / getter : bool이 아닌 필드를 직접 할당하거나 반환하는 메서드
  - private 필드를 다루기 위한 메서드
- 객체의 필드에 대한 getter가 존재하는 순간 캡슐화를 해제하고 불변속성을 전역화
  - 객체를 얻은 어느 곳에서나 public메서드를 호출할 수 있으며, 예상하지 못한 방식으로 객체를 수정 가능
- setter도 마찬가지, setter를 통한 새로운 데이터 구조를 반환하도록 getter를 수정하고 새로운 데이터구조를 받을 수 있도록 해야한다 
  - 이는 우리가 피해야 할 tight coupling
  - 내부 데이터 구조를 변경하고, 해당 setter를 수정해도 시그니처를 유지할 수 있는 다른 간접적인 레이어를 도입하는 것은 우리가 말하는 setter가 아니므로 괜춘
- 가변 객체에서만 발생하는 문제. 
- push based(푸시 기반)의 아키텍처를 장려: 필드를 비공개로 하는 것의 가장 큰 장점
  - 데이터에 가깝게 연산을 이관
  - c.f. pull based (풀 기반) 아키텍처: 데이터를 가져와 중앙에서 연산 수행
    - 풀 기반의 아키텍처에서는 기능을 수행하는 메서드 없이, 수동적 데이터 클래스와 관리자 클래스 (여기저기서 데이터를 혼합하여 모든 작업을 수행하는 소수) 존재
    - 데이터와 관리자 사이, 그리고 데이터 클래스 간에 tight coupling 초래
  - 푸시 기반 아키텍처에서는 데이터를 가져오는 대신 인자로 데이터를 전달. 
  - 모든 클래스가 자신의 기능을 가지고 있으며, 코등는 그 효용에 따라 분산
- 낯선 사람에게 말하지 말라(디미터/데메테르 법칙: Law of Demeter)
  - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다
  - 낯선 사람: 우리가 직접 접근할 수는 없지만 참조를 얻을 수 있는 객체
  - 객체 지향 언어에서는 이런 일이 일반적으로 getter를 통해 존재
- 참조를 얻을 수 있는 객체와 상호작용할 때의 문제: 객체를 가져오는 방식과 tight coupling
  - 객체 소유자의 내부 구조에 대해 어느 정도 알고 있어야 한다.
  - 필드 소유자가 이전 데이터 구조를 획득하는 방법을 계속 지원하지 않는 한 데이터 구조를 변경할 수 없다.
  - c.f. 푸시 기반 아키텍쳐에서는 서비스와 같은 메서드를 노출. 사용하는 메서드 내부 구조에 대해 신경쓰지 않아도 된다.

### 6.1.2 규칙 적용하기

- pull based -> push based

### 6.1.3 리팩터링 패턴: getter와 setter 제거하기

- 기능을 데이터에 더 가깝게 이동하여 getter와 setter를 제거해보자
- 코드를 데이터에 더 가깝게 이동함으로써 불변 속성을 지역화
- getter를 비공개로 바꾸고, 클래스로의 코드 이관을 실행한 후 getter를 인라인화 

### 6.1.4 마지막 getter 삭제

## 6.2 간단한 데이터 캡슐화하기

### 6.2.1 규칙: 공통 접사를 사용하지 말 것

- 코드에는 공통 접두사나 접미사가 있는 메서드나 변수가 없어야 한다.
- 여러 요소가 동일한 접사를 가진다 -> 요소들의 긴밀성
- 클래스로 이런 메서드와 변수를 그룹화
  - 외부 인터페이스를 완전하게 제어할 수 있다.
  - 도우미 메서드를 숨겨 전역 범위를 오염시키지 않을 수 있다.
    - 다섯 줄 제한 규칙은 많은 메서드를 도입하므로 특히 이 방법이 중요
  - 데이터를 숨김으로써 해당 불변속성이 클래스 내에서 관리
    - 지역 불변속성이 되어 유지보수하기가 더 쉬워진다.
- 단일 책임 원칙: '메서드는 한 가지 작업만 해야 한다'의 클래스 버전 -> 클래스에는 단 하나의 책임만 있어야 한다.

