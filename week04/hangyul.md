2부: 배운 내용을 현실 세계에 적용하기

# 7장 컴파일러와의 협업

- 컴파일러의 역할
  - 코드를 높은 수준의 언어에서 낮은 수준의 언어로 변환
  - 여러 속성의 유효성을 검사
  - 프로그램 실행 시 특정 오류가 발생하지 않도록 보장

## 7.1 컴파일러에 대해 알아보기

- 컴파일러는 프로그램이다
- 컴파일러의 목표는 소스 프로그램과 동일한 다른 언어로 된 프로그램을 생성하는 것이지만, 우리가 주목할 것은 런타임 중에 특정 오류가 발생할 수 있는지도 확인하는 기능

### 7.1.1 약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다.

- 정지 문제(halting problem): 실행하지 않고는 (런타임 동안 어떤 일이 일어날지) 정확히 말할 수 없는 이유
- 보수적 분석(conservative analysis): 프로그램이 안전하다고 보장할 수 없는 경우 허용하지 않는다.
  - 특정한 실패 가능성이 없다는 것을 보증

### 7.1.2 장점: 도달성 검증은 메서드의 반환을 보장한다.

- 보수적인 분석 중 하나는 메서드가 모든 경우에서 return되는지 확인하는 것. 
- 완전 검사(exhaustiveness check): switch문에서 모든 case를 포함하고 있는지 확인

### 7.1.3 장점: 할당은 초기화되지 않은 변수에 대한 접근을 막는다

- 변수가 사용되기 전에 변수에 값이 확실히 할당되었는지 여부 확인
- 초기화가 반드시 될 조건을 가지고 있음을 확정 할당 분석(definite assignment analysis)이 적용되는 읽기 전용 (또는 final) 필드를 사용해서 알리지 않는다면, 초기화되지 않은 변수에 대해 접근할 때 컴파일러는 오류라고 인식한다.
  - 생성자를 종료할 때 읽기 전용 필드가 초기화 되어야 한다.
  - 생성자에서 할당하거나, 선언 시 할당해야 한다.

### 7.1.4 장점: 접근 제어로 데이터 캡슐화를 지원한다.

- 멤버를 비공개로 하면 오용되지 않을 것이라 확신할 수 있다.
- p.216 이것은 서로 다른 객체가 동일한 클래스인 경우 다른 객체의 private 멤버를 검사할 수 있음을 의미합니다.
  - 뭔말이여... 
  - private applies to the class, not the object. This means we can inspect another object’s private members if it is of the same class.

### 7.1.5 장점: 타입(형) 검사기는 속성을 보증한다.

- 변수와 멤버가 존재하는지 확인하고, 순서 강제화를 가능하게 한다.
- 프로그램의 속성을 정의하는, 최고 수준의 보안

### 7.1.6 약점: null을 역참조하면 애플리케이션이 손상된다.

- 예제 7.6 잠재적인 null 역참조?

### 7.1.7 약점: 산술 오류는 오버플로나 손상을 일으킨다.

- 0으로 나누기 연산, 오버플로 될 수 있는 여부 등 산술 오류(arithmetic error)
- 오버플로: 최대 9999까지 표현 가능한 기기에서 9999에 1을 더할 때 발생하는 10진수 오버플로 

### 7.1.8 약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다.

- out of bounds: 데이터 구조의 범위 내에 있지 않은 인덱스에 접근하려 할 때
- 해결책
  - 기대하는 요소를 찾지 못할 위험이 있는 경우 전체 데이터 구조를 탐색 traverse the entire data structure (이건 또 뭔말일까)
  - 요소가 확실하게 있음을 증명하기 위해 확정할당에 대해 앞에서 논의한 접근 방식 사용

### 7.1.9 약점: 무한루프는 애플리케이션을 지연시킨다.

- while -> for -> foreach 및 최근에는 더 높은 수준의 구성으로 전환함으로써 문제가 감소 중
- These issues are being reduced by transitioning away from while to for and then foreach, and recently to higher-level constructions such as forEach in TypeScript, stream operations in Java, and LINQ in C#.

### 7.1.10 약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다.

- 변경 데이터를 공유하는 여러 스레드가 있으면 교착 상태, 경쟁 상태, 기아 등의 문제가 발생
  - 타입스크립트는 다중 스레드를 지원하지 않으므로 그럴 일이 없지만...
- 경쟁 상태 (race condition)
  - 두 개 이상의 스레드가 공유하는 변수를 읽고 쓰기 위해 경쟁
  - 두 스레드가 업데이트하기 위해 동시에 동일한 값을 읽는 것
  - 해결하기 위해서는 lock을 도입하여 다른 스레드의 잠금이 해제됐는지 확인
- 교착 상태(deadlock)
  - 두 스레드가 모두 잠겨있고 계속 진행하기 전에 서로가 잠금 해제를 기다리고 있을 때
  - starvation 상태로 이어진다. 
- 변경 가능한 데이터를 공유하는 다중 스레드를 사용하지 마라 ^^...

## 7.2 컴파일러 사용

- 프로그램은 시간이 고정된 도메인에 대한 개발팀의 공동 지식
- 컴파일러는 우리의 텍스트가 특정 품질을 충족하는지 확인하는 편집자

### 7.2.1 컴파일러 활용

- todo 리스트로 안정성 확보
  - 변경하고 싶을 때 원래 메서드의 이름을 바꾸고 컴파일러에 의존, 어떤 참조도 놓치지 않으므로 다른 모든 곳을 확인 가능
- 순서 강제화를 이용한 안전성 확보
- 캡슐화 강제를 통한 안전성 확보
  - 엄격한 캡슐화를 강제하기 위해 컴파일러의 접근 제어를 사용해서 불변 속성을 지역화
  - private메서드로 지정해서 누군가 실수로 메서드를 호출하지 못하도록
- 컴파일러로 사용하지 않는 코드 감지
  - 사용되지 않는 코드라 생각하면 지운 후 컴파일 되는지 확인
- 확정 값을 통한 안정성 확보
  - 초기화 되지 않은 읽기 전용 필드가 있는 객체는 생성할 수 없다

### 7.2.2 컴파일러와 싸우지 말 것

- 타입 검사기를 속이거나 무력화하는 것
  - 형 변환: 컴파일러를 특정 변수나 표현식에 대해 비활성화. 
    - 형 변환을 해도 되는 곳은 형식화되지 않은(untyped) JSON을 얻을 때
    - 자신이 제어할 수 있는 곳에서 입력을 받거나
    - 보내는 측과 받는 측이 동일한 타입을 재사용하는 경우
    - 사용자 정의 파서로 입력을 분석하는 것
  - 동적 타입: 타입 검사기를 비활성화 하는 것
  - 런타임 타입: 컴파일 시간에서 런타임으로 판단에 필요한 정보를 옮기는 것
    - "빨래가 지겹나요? 모든 옷을 태우세요!" ㅋㅋㅋ
    - 특정 필드들로 객체를 만드는 것
- 게으름
  - 단기적인 해결책을 위해 지름길을 택하지 말라
  - 기본값
    - 기본값을 사용하는 대신 개발자가 무언가를 추가하거나 변경할 때마다 직접 처리하게 하라
    - 우리가 필요한 변수의 사용을 놓쳤을 때, 컴파일러가 발견하여 알려줄 수 있다.
  - 상속: 인터페이스에서만 상속받을 것
  - 처리를 강제하지 않은 예외 (unchecked exception)
- (마이크로) 아키텍처에 대한 이해 부족
  - 마이크로 아키텍처: 팀에 영향을 미치지만 다른 팀에는 영향을 주지 않는 아키텍처
  - getter/setter로 캡슐화를 깨는 것 or private 필드를 외부 함수에 인자로 전달하는 경우
  - p.234 대신 불변속성을 지역적으로 유지할 수 있도록 this를 전달해야 한다? 